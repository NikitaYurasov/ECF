# Elliptic Curve Factorization
[![](https://img.shields.io/pypi/v/pyecf.svg?style=flat-square)](https://pypi.org/project/pyecf/)

Данный модуль предназначен для нахождения всех делителей числа 
(факторизация, разложение на простые множители). В качестве метода факторизации
используется [алгоритм](https://wstein.org/edu/124/lenstra/lenstra.pdf), предложенный Хендриком Ленстрой в 1987 году.

## Использование через командную строку
Для использования в терминале достаточно установить пакет:
```shell
git clone https://github.com/NikitaYurasov/ECF.git
cd ECF
```
И выполнить следующую команду:
```shell
python pyecf -n 9671406556917033397649407
```

## Использование в Python
Пакет выложен на PyPi, так что достаточно просто установить его через *pip*:
```shell
pip install pyecf
```
Внутри проекта использование может выглядеть так:
```python
from pyecf import LenstraAlgorithm

n = 9671406556917033397649407
algo = LenstraAlgorithm(n)
factors = algo.factorize() # factors - отсортированный список делителей
```

## Описание алгоритма

Пусть требуется найти делить числа $$n$$. Считаем, что у числа $$n$$ существует делить $$d$$ ($$1<d<n$$). Сгенерируем тройку чисел $$a, x_0, y_0$$ для случайной эллиптической кривой $$y^2=x^3+ax+b$$ над $$Z/nZ$$, где $$b = y_0^2 - x_0^3-ax (\mod n)$$ и с условием, что кривая не сингулярна ($$4a^3+27b^2\ne 0\mod n$$). Случайной точкой на кривой выберем $$P(x : y) = (x_0 : y_0)$$. 

Пусть также задано число $$k$$, обозначающее степень, в которое будем возводить начальную точку $$P$$: $$k=\prod\limits_{r=2}^{\omega}r^m$$, где $$r^m\leq \nu+2\sqrt{\nu}+1$$ и $$r$$ -- некоторые целые положительные числа.

Следующим шагом выполняется возведение в степень на выбранной кривой:

$$kP = \underbrace{P+ P+ .... + P}_k$$, где операция $$+$$ определена по следующему алгоритму:
### Алгоритм сложения
Требуется сложить две точки $$P$$ и $$Q$$: $$R=P+Q$$

1. Если $$P=\mathcal{O}$$, то $$R=Q$$; если $$Q=\mathcal{O}$$, то $$R=P$$.
2. Иначе, пусть $$P=(x_1, y_1), Q=(x_2, y_2)$$
    a. Найти $$d=\gcd(x_1-x_2, n)$$. Если $$1<d<n$$, то $$d$$ -- делитель $$n$$. Конец алгоритма.
    b. Если $$d=1$$, то НОД дает $$(x_1-x_2)^{-1}$$
        $$\lambda=(y_1-y_2)(x_1-x_2)^{-1}$$
        $$x_3=\lambda^2-x_1-x_2;\: y_3=\lambda(x_1-x_3)-y_1$$
        $$R=(x_3, y_3)$$
        Конец алгоритма.
    c. Если $$d=n$$, тогда $$x_1=x_2$$. Требуется найти $$d=\gcd(y_1 + y_2, n)$$. 
    - Если $$1<d<n$$, $$d$$ -- делитель, конец алгоритма. 
    - В противном случае, если $$d=n$$, считаем, что $$R=\mathcal{O}$$, конец алгоритма.
    - Если $$d=1$$, то $$\lambda=(3x_1^2+a)(y_1+y_2)^{-1}$$ и $$R=(\lambda^2-x_1-x_2, \lambda(x_1-x_3)-y_1)$$
    
Стоит заметить, что если в ходе алгоритма получается сингулярная кривая, выбор кривой необходимо повторить. Если в ходе алгоритма делитель не нашелся, алгоритм стоит запустить еще раз.


### Нахождение всех делителей числа

1. Пусть заданы два массива: пустой массив для простых делителей и массив с составными делителями. 
   На первом шаге, во втором массиве находится число $$n$$.
   
2. По всем числам из массива составных делителей пока он не пустой:
    - Берем первое число;
    - Проверяем на простату (тест Миллера-Рабена): если число простое, заносим его в массив
    простых чисел, и удаляем первое число из массива составных чисел;
    - Если не простое, проверяем на четность: если число четное, в список простых делителей заносим
    2, в список составных - $$n/2$$ в конец;
    - Если не четное, аналогично проверяем делимость на 3;
    - В противном случае используем алгоритм Ленстры для поиска делителя, пока он не будет найден. 
      Когда делитель найден, добавляем его и $$n/d$$ в список составных делителей в конец.
      
3. Результатом алгоритма будут все числа из списка простых делителей.


### Скорость работы
Время работы данного алгоритма зависит не от самого факторизуемого числа, а то размера наименьшего делителя.

Время работы:
![Время работы](./tests/speedtest_run.jpg)